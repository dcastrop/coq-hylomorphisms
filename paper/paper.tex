\documentclass{llncs}
% \documentclass[llncs, a4paper, UKenglish, cleveref, autoref, thm-restate]{article}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
% \usepackage[backend=bibtex,style=alphabetic,natbib=true]{biblatex}
% \usepackage[backend=bibtex,style=alphabetic,natbib=true]{biblatex}
% \addbibresource{references.bib}
\pagestyle{plain}

\usepackage{amsmath, mathpartir}
%, amssymb, amsfonts, stmaryrd}
% \usepackage{mathpartir}
% \usepackage{bussproofs}

\usepackage{caption}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{xparse}
\usepackage[usenames, dvipsnames]{xcolor}
\usepackage{lipsum}
\usepackage{xargs}
\usepackage{hyperref}
\usepackage{tikz-cd}
\usepackage{todonotes}
\usepackage{url}
\usepackage{xspace}
\usepackage{rotating}
\usepackage{quiver}
\usepackage{minted}
\usepackage{newunicodechar}
\usepackage{microtype}
% \addbibresource{references.bib}
\usepackage{array}   % for \newcolumntype macro
\newcolumntype{C}{>{$}c<{$}} % math-mode version of "l" column type
\newcolumntype{L}{>{$}l<{$}} % math-mode version of "l" column type

% \usepackage{draftwatermark}
% \SetWatermarkText{Confidential}
% \SetWatermarkScale{4}
% \SetWatermarkColor[gray]{0.9}

\hypersetup{
  linktocpage,
  colorlinks,
  citecolor=BlueViolet,
  filecolor=red,
  linkcolor=Blue,
  urlcolor=BrickRed
}
\newcommand{\mpav}[1]{\textcolor{red}{\textsc{Marco}: #1}}
\newcommand{\dcas}[1]{\textcolor{ForestGreen}{\textsc{David}: #1}}
\newcommand{\mvol}[1]{\textcolor{blue}{\textsc{Michael}: #1}}
% \newcommand{\proofcomment}[1]{\text{\{ #1 \}}}
% \newenvironment{proofof}[1] {\begin{proof}[Proof of {#1}]}{\end{proof}}
\newcommand{\eqdef}{\stackrel{\mathrm{\Delta}}{=}}
\newcommand{\eqiff}{\stackrel{\triangle}{\iff}}
\newcommand{\bnfeq}{\mathrel{::=}}
\newcommand{\defeq}{\triangleq}
\newcommand{\rul}[3]{\frac{#2}{#3}\;  {\textrulelabel{#1}}}
\newcommand{\den}[1]{\llbracket #1 \rrbracket}
\newcommand{\jud}[3]{#1 \vdash #2 : #3}
\newcommand{\bden}[1]{\llparenthesis#1 \rrparenthesis}
\newcommand{\bigslant}[2]{{\raisebox{.2em}{$#1$}\left/\raisebox{-.2em}{$#2$}\right.}}
\newcommand{\quotient}[2]{\bigslant{#1}{#2}}
\newcommand{\curry}{\Lambda}
\newcommand{\uncurry}{\begin{sideways}\begin{sideways}$\Lambda$\end{sideways}\end{sideways}}
\newcommand{\Bool}{\mathbb{B}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Nat}{\N}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Sets}{\mathbf{Set}}
\newcommand{\blacklater}{\blacktriangleright}
\newcommand{\tot}{\mathcal{S}}
\newcommand{\PSh}{\ensuremath{\textbf{PSh}(\omega)}}

\input{lensbans}

\newcommand{\anamor}[1]{{\llens\, #1\, \rlens}}
\newcommand{\catamor}[1]{\lbans\, #1\, \rbans}
\newcommand{\cata}[1]{\lbans #1 \rbans}
\newcommand{\ana}[1]{\llens #1 \rlens}
\newcommand{\catafree}[1]{\Lbanana #1 \Rbanana}
\newcommand{\anacofree}[1]{\Llens #1 \Rlens}
\newcommand{\hylo}[2]{\cata{#1 \to #2}}
\newcommand{\cohylo}[2]{\ana{#1 \to #2}}
\newcommand{\fold}[1]{\catamor{#1}}
\newcommand{\unfold}[1]{\anamor{#1}}
\newcommand{\comp}{\cdot}
\newcommand{\operator}[1]{\textsf{#1}}
\newcommand{\head}{\operator{head}}
\newcommand{\inl}{\operator{inl}}
\newcommand{\inr}{\operator{inr}}
\newcommand{\tail}{\operator{tail}}
\newcommand{\Alg}{\text{-Alg}}
\newcommand{\Coalg}{\text{-CoAlg}}
\newcommand{\Free}{\text{Free\xspace}}
\newcommand{\fmap}[1]{\text{fmap}\;#1}

\newcommand{\zero}{\operator{zero}}
\newcommand{\Nil}{\operator{nil}}
\newcommand{\Succ}{\operator{succ}}

\newcommand{\InOp}{\operator{in}^{\circ}}
\newcommand{\InIso}{\operator{in}}
\newcommand{\OutOp}{\operator{out}^{\circ}}
\newcommand{\OutIso}{\operator{out}}
\newcommand{\call}{\operator{call}}

\newcommand{\CatC}{\mathcal{C}}
\newcommand{\CatD}{\mathcal{D}}
\newcommand{\CatE}{\mathcal{E}}
\newcommand{\CatI}{\mathcal{I}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\iso}{\cong}
\newcommand{\ceiling}[1]{\lceil #1 \rceil}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\pair}[2]{\langle #1, #2 \rangle}
\newcommand{\haskell}[1]{\mintinline{haskell}{#1}}
%\newcommand{\coq}[1]{\mintinline{coq}{#1}}

\newcommand{\Hom}{\text{Hom}}
\newcommand{\Obj}{\text{Obj}}
\newcommand{\Arr}{\text{Arr}}

\newcommand{\Str}[1]{\operator{Str}(#1)}
\newcommand{\List}[1]{\operator{List}(#1)}
\newcommand{\Strbare}{\operator{Str}}
\newcommand{\Listbare}{\operator{List}}
\newcommand{\nil}{\operator{nil}}
\newcommand{\cons}{\operator{cons}}
\newcommand{\foldr}{\operator{foldr}}

\newmintinline[coq]{coq}{fontsize=\small}
\newmintinline[ocaml]{OCaml}{fontsize=\small}
\newminted{coq}{fontsize=\small}
\newminted{ocaml}{fontsize=\small}

\title{Mechanising Recursion Schemes with Magic-Free Coq Extraction}

\bibliographystyle{plainurl}% the mandatory bibstyle
%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

% \author{David Castro-Perez}{School of Computing, University of Kent}{d-castro-perez@kent.ac.uk}{}{}
% \author{Marco Paviotti}{School of Computing, University of Kent}{m.paviotti@kent.ac.uk}{}{}
% \author{Michael Vollmer}{School of Computing, University of Kent}{m.vollmer@kent.ac.uk}{}{}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Generic programming with recursion schemes provides a powerful abstraction for
structuring recursion while ensuring termination and providing reasoning about
program equivalences, as well as deriving optimisations which have been
successfully applied to functional programming. Formalising recursion schemes in
a type theory offers additional termination guarantees, but it often requires
compromises affecting the resulting code, such as imposing performance
penalties, requiring the assumption of additional axioms, or introducing unsafe
casts into extracted code (e.g. \ocaml{Obj.magic} in OCaml).

To the best of our knowledge, this paper presents the first Coq formalisation of
a recursion scheme, called the \emph{hylomorphism}, along with its algebraic
laws allowing for the mechanisation of all recognised (terminating) recursive
algorithms. The key contribution of this paper is that this formalisation is
fully axiom-free allowing for the extraction of safe, idiomatic OCaml code. We
exemplify the framework by formalising a series of algorithms based on different
recursive paradigms such as divide-and conquer, dynamic programming, and mutual
recursion and demonstrate that the extracted OCaml code for the programs
formalised in our framework is efficient, resembles code that a human programmer
would write, and contains no occurrences of \ocaml{Obj.magic}.  We also present
a machine-checked proof of the well-known short-cut fusion optimisation.
\end{abstract}

\section{Introduction}
\label{sec:intro}
Structured recursion schemes~\cite{HinzeW16,HinzeWG15} are powerful
abstractions that capture common patterns of recursion. The main benefit of
structuring computation using recursion schemes, is that they enjoy
well-estabished \emph{algebraic properties} that can serve as a foundation for
program optimisation (e.g.\ \emph{fusion} laws, or semi-automatic
parallelisations~\cite{TakanoM95,Gibbons96:Third,Morihata09:Third,farmsCastro}).
These algebraic properties led to their use in the context of
\emph{program calculation}, where programmers would describe their code using
simple, inefficient specifications in an \emph{algebra of
programming}~\cite{BirddeMoor96:Algebra}, and then use the algebraic laws of
this algebra of programming to \emph{calculate} an efficient version of the same
algorithm. Suppose, for example, that we want to write a program sorts a list of
integers, and then multiplies by 2 all its elements. In OCaml, we may write this
function directly:
\begin{minted}{ocaml}
let rec sort_times_two = function
  | [] -> []
  | h :: t -> let (l, r) = partition (fun x -> x < h) t in
  sort_times_two l @ (h * 2) :: sort_times_two t
\end{minted}
Instead of writing this function directly, we may observe that we can derive it
by \emph{fusing} a regular \emph{quicksort} OCaml implementation, with
\ocaml{map (fun x -> x * 2)}. This is the main idea behind program calculation:
start
from a simple specification, e.g.\
$\mathsf{map}\;(\lambda x.\;x \times 2) \circ \mathsf{sort}$, and use program
equivalences and algebraic laws to rewrite it to an optimised version  (e.g.\
the fused OCaml implementation above). We will revisit a similar example
in Section~\ref{sec:sorting}.

Despite the rigorous set of algebraic laws that are satisfied by recursion
schemes, there is a lack of tool support for their use in the context of program
calculation. In fact, most of the work on applying program calculation is done
by performing pen-and-paper proofs, and then translating the result to specific
instances of recursion schemes, implemented in a programming language (generally
Haskell). There are some examples of implementations of program calculation
techniques, but these implementations are scarce, not up to date, and not
verified. For example, Cunha et al. automated program calculation techniques by
a custom Haskell implementation~\cite{DrHylo}.

Several authors build tools for applying program calculation techniques by
\emph{mechanising} them as part of a proof assistant. However, most of the work
in mechanising recursion schemes focuses on a narrow subset of the known
recursion schemes due to termination issues, or do not focus on proving
algebraic laws of generic recursion schemes~\cite{10.1007/978-3-642-17796-5_10,MurataE19,larchey2022braga}.
Indeed, most of the mechanisations of generic
recursion schemes focus on \emph{maps} and \emph{folds}, and few authors focus
on the \emph{unfolds}. In general, Hinze et al.~\cite{HinzeWG15} has proven that
all known  recursion schemes are instances of a  divide-and-conquer algorithm
which goes under the name of \emph{hylomorphism}~\cite{MeijerFP91,HuIT96}.  To
date, no work has mechanised hylomorphisms in the Coq proof assistant, together
with their algebraic laws.

Recently, Abreu et al.~\cite{AbreuDHJMS23} encoded an algebraic approach to
divide-and-conquer computations in which termination is entirely enforced by the
typing discipline. Their approach solves the problem of termination proofs as
well as the performance of the code that is run \emph{within Coq}, but it does
not allow for extraction of idiomatic OCaml code. This is unfortunate since code
extration is what allows the execution of code that has been verified in
Coq~\cite{OnoHTNH11,Larchey-Wendling23,MiculanP12,Sakaguchi20}.  In Abreu et
al.'s approach, extraction (1) does not preserve the recursive structure of
common implementations; and (2) leads to unsafe casts like \ocaml{Obj.magic} in
the generated code. This latter is also problematic in that, for higher-order
programs, simple interoperations can lead to incorrect behaviour or even
segfaults~\cite{forster:hal-04329663} and, moreover, it invalidates the
fast-and-loose principle~\cite{DanielssonHJG06}.

This work presents the first Coq formalisation \emph{hylomorphisms} that (1) is
\emph{axiom-free} and (2) allows the extraction of idiomatic OCaml code. The
full mechanisation can be found on
Github\footnote{https://github.com/dcastrop/coq-hylomorphisms}\dcas{I SHOULD
ANONYMISE THIS}. While programmers still need to reason about the termination of
their programs, our mechanisation will allow the use of the algebraic laws of
hylomorphisms for \emph{program calculation}, as well as extracting to idiomatic
code (see examples of extracted code in Section~\ref{sec:examples}).
% As an example, our mechanisation of \ocaml{qsort} as a
% hylomorphism will produce the following code:
% \begin{coqcode}
% let rec qsort = function | [] -> []
%   | h :: t -> let (l, r) = partition (fun x0 -> (<=) x0 h) t in
%               let cx = fun p -> match p with | Lbranch -> l | Rbranch -> r in
%               app (qsort (cx Lbranch)) (h :: (qsort (cx Rbranch)))
% \end{coqcode}

To summarise, our contributions are as follows. In this paper we provide a
framework for \emph{program calculation} with recursion schemes in Coq, where
program calculation is done by applying regular Coq equalities, based on  proofs
of the algebraic laws of hylomorphisms, and that allows the extraction of safe,
idiomatic OCaml code:
\begin{itemize}
  \item In Section~\ref{sec:containers} we formalise the type of container
functors ensuring the presence of least and greatest fixed-points for functors
and suitably adapted for program extraction
  \item In Section~\ref{sec:recursion-schemes} we formalise folds, unfolds and
hylomorhisms and their universal properties
  \item In Section~\ref{sec:examples} we use the framework to formalise examples
of divide-and-conquer, dynamic programming, and mutual recursion algorithms.
Furthermore we verify the short-cut fusion optimisation and show the extracted
optimised code to OCaml.
\end{itemize}

\section{Recursion Schemes}
The structure of the a certain data is very similar to the structure of an
algorithm which processes that data. This relationship manifests in the form of
structured recursion schemes which are widely used in functional languages such
Haskell. Canonical examples are folds (catamorphisms), which consume data, and
unfolds (anamorphisms), which produce it. While some implementations of
recursion schemes like $\operator{foldr}$ in Haskell as specific to a particular
data structure, in this case $\operator{List}$s, we can generalise further these
ideas to account for generic (co)inductive data types and generic algorithms
operating on them.

Furthermore folds and unfolds can be shown to capture a wide
range of recursion schemes such as primitive recursion, mutual recursion,
dynamic programming algorithms, polymorphic recursion, recursion with
accumulators and so on. However, for divide-and-conquer algorithms folds need to
be generalised to hylomorphisms which provide the ultimate basic building block
for any other recursion scheme. This is done by looking at recursion schemes
from the point of view of category theory.

\subsection{Elements of Category Theory}
A \emph{category} is a collection of objects $A, B, C$, denoted by $\Obj(\CatC)$
and a collection of arrows $f, g, h$ between these objects, denoted by
$\Arr{\CatC}$, such that there always exists an identity arrow
$id_{A} : A \to A$ for each object $A$ and for two arrows $A \xrightarrow{f} B$
and $B \xrightarrow{g} C$ there always exists an arrow
$A \xrightarrow{g\circ f} C$ obeying the associativity law. We denote
$\Hom_{\CatC} (A, B)$ the set of arrows from $A$ to $B$ and we use the letters
$\CatC$, $\CatD$, $\CatE\dots$ for categories\footnote[1]{For presentation
purposes we shall not deal with size issues and assume all the categories are
small.}. The initial object in a category, denoted by $0$, is the object such
that for any other object $A$ there is a unique arrow $0 \xrightarrow{!} A$.
Dually, the terminal object, denoted by $1$, is the object such that for any
other object $A$ there is a unique arrow $A \xrightarrow{!} 1$. Initial and
terminal object are unique up-to isomorphism.

For example, the category of sets, denoted by $\Set$, is the category where
objects are sets and arrows are functions between sets. The initial object $0$
in $\Set$ is the empty set $\emptyset$ and the terminal object $1$ is any
singleton set. The reader who is not accustomed with category theory can assume
types are sets, giving the intuition that the category $\Set$ can also be viewed
as the category of (simple) types and programs between them.

A \emph{functor} $F : \CatC \to \CatD$ is a map between categories mapping both
objects and arrows from one category to another. Hence a functor has two
components, one which maps objects into objects
$F : \Obj(\CatC) \to \Obj(\CatD)$ and one which maps arrows into arrows
$F : \Hom_{\CatC}(A, B) \to \Hom_{\CatD} (FA,FB)$ such that identity and
composition of arrows are preserved:
\begin{mathpar}
  F(id_A) = id_{FA} \and F(g \circ f) = F(g) \circ F(f)
\end{mathpar}
This latter component is also called the \emph{functorial action}.

In $\Set$, we can define the set of lists
\[
  \List{A} \iso 1 + A \times \List{A}
\]
as the set inductively generated by the
constructors $\nil : 1 \to \List{A}$ and
$\cons : A \times \List{A} \to \List{A}$. This set extends to a functor
$\Listbare : \Set \to \Set$. Its functorial action has type
$\List{f} : \List{A} \to \List{B}$ for a morphism $f : A \to B$ and it is given
by $\List{f}(*) = *$ and $\List{f}(\cons(a,xs)) = \cons(f(a), \List{f}(xs))$.
Notice that the definition $\List{f}$ is well-defined as it recursively calls on
a smaller argument.

Similarly, the set of streams
\[
  \Str{A} \iso A \times \Str{A}
\]
is the greatest set generated by the constructor
$\cons : A \times \Str{A} \to \Str{A}$. This set also extends to a functor
$\Strbare : \Set \to \Set$ whose functorial action is simply
$\Str{f}(\cons(a,s)) = \cons (f (a), \Str{f}(s))$ defined coinductively.


\subsection{Algebras and Catamorphisms}
\label{sec:algebras}
For a functor $F : \CatC \to \CatC$ an $F$-\emph{algebra} is a pair $(A,\alpha)$
where $A$ is an object of the category called the \emph{carrier} of the algebra
and $\alpha$ is an arrow of type $FA \to A$ called the \emph{structure map}.
The category of $F$-algebras, denoted by $F\Alg(\CatC)$, is the category where
objects are $F$-algebras and arrows $f : (A, \alpha) \to (B, \beta)$ are
\emph{$F$-algebra homomorphisms}  $f : A \to B$ in $\CatC$ such that they
respect the structure of the algebra, that is
$f \circ \alpha = \beta \circ F(f)$. The initial object in this category is
called the \emph{initial $F$-algebra}, that is the $F$-algebra which has a
unique $F$-algebra homomorphism into any other $F$-algebra. By Lambek's lemma
the initial $F$-algebra is precisely the \emph{least fixed-point} for the
functor $F$ which we denote by $(\mu F, \InIso)$ with
$\InIso : F \mu F \to \mu F$ and $\InOp : \mu F \to F \mu F$ witnessing the
isomorphism $F\mu F \iso \mu F$.
By the property of initial $F$-algebras, for
any other $F$-algebra $(B, \beta)$ there exists a unique $F$-algebra
homomorphism, denoted by $\cata{\beta} : (\mu F, \InIso) \to (B, \beta)$ and
pronounced ``\emph{catamorphism}'' satisfying:
\begin{equation}
  \label{eq:cata:unique}
  f = \cata{\alpha} \iff f = \alpha \circ F(f) \circ \InIso
\end{equation}
In words, any $F$-algebra homomorphism from the initial $F$-algebra is a
catamorphism.

For example, for a set $A$ we define the functor $F : \Set \to \Set$ mapping
$X \mapsto 1 + A \times X$. An $F$-algebra is a set $B$ together with a
structure map $[base, ind] : 1 + A \times B \to B$. The initial $F$-algebra is
clearly the set of lists $\List{A}$. The catamorphism associated with the type
of lists is the unique arrow recursively translating the initial algebra
$[\nil,\cons]$ into the algebra $[base, ind]$:

In functional programming this is commonly referred to as
$\foldr : (1 \to B) \to (A \times B \to B) \to B$. We can in fact set
$\foldr\;base\;ind = \cata{[base, ind]}$.

\subsection{Coalgebras and Anamorphisms}
\label{sec:coalg}
The dual of an algebra is a coalgebra. For an endofunctor $B : \CatC \to \CatC$,
a $B$-\emph{coalgebra} is a pair $(X, c)$ where $X \in \Obj(\CatC)$ is the
carrier of the coalgebra and $c : X \to BX$ is a morphism.

For example, for a set of states $X$ and a finite set of labels $L$ we can
define a labelled transition system (LTS) on $X$ as a function $X \to BX$
implementing the \emph{transition system} with $BX = L \times X$.  In
particular, for a state $x \in X$, $c(x_{1})$ returns a pair $(l, x_{2})$ where
$l \in L$ is the observable action and $x_{2} \in X$ is the next state.  In this
case, we can even set some notation for the transition map:
\[
  x \xrightarrow{l} y \eqdef c(x) = (l, y)
\]
The category of $B$-coalgebras, denoted $B\Coalg$, is the category where objects
are $B$-coalgebras and morphisms $f : (X, \gamma_{X}) \to (Y, \gamma_{Y})$ are
$B$-coalgebra homomorphisms $f : A \to B$, that is
$ \gamma_{Y} \circ f = F(f) \circ \gamma_{X}$. Terminal object in this category
$B$-coalgebra corresponds to the greatest fixed-point for the functor $B$,
denoted by $(\nu B, \OutIso)$ where $\OutIso$ denotes the final $B$-coalgebra
$\OutIso : \nu B \to B\nu B$. For

For example, the terminal coalgebra for the functor $BX = L \times X$ is the set
of of infinite streams, that is the greatest solution to the domain equation
$\Str{A} \iso A \times \Str{A}$.  As a result, for any $B$-coalgebra
$(B, \gamma)$ there exists a unique $B$-coalgebra homomorphism into the terminal
coalgebra $(\nu B, \OutIso)$ which is denoted by $\ana{\gamma}$ and pronounced
\emph{anamorphism}. We spell out the uniqueness property:
\begin{equation}
  \label{eq:ana:unique}
  f = \ana{\gamma} \iff f = \OutOp \circ B(f) \circ \gamma
\end{equation}
In words, for any $B$-coalgebra, if there is any other $B$-coalgebra
homomorphism $f$ into the terminal object then it must be the anamorphism on the
same coalgebra.

\subsection{Recursive Coalgebras and Hylomorphism}
\label{sec:rec-coalgebras}
Recursion schemes provide an abstract way to consume and generate data capturing
\emph{divide-and-conquer} algorithms where the input is first destructured
(\emph{divide}) in smaller parts by means of a coalgebra which are computed
recursively and then composed back together (\emph{conquer}) by means of an
algebra.

In general given an $F$-algebra and $F$-coalgebra, the hylomorphism is the
unique solution (when it exists) to the equation
\begin{equation}
  \label{eq:hylo}
  f = a \circ F\; f \circ c
\end{equation}
As we stated earlier, a solution to this equation does not exist for an
arbitrary algebra and coalgebra pair and, in fact, this definition cannot be
accepted by Coq.

In order to find a solution we restrict ourselves to the so-called
\emph{recursive coalgebras}~\cite{AdamekMM19,CaprettaUV04}.
A $F$-coalgebra $(X, c)$ is recursive if

An example of a
recursive coalgebra is the \coq{partition} function in quicksort which
destructures a list into a pivot and two sublist and as long as the sublists are
smaller the partitioning function still yields a unique solution to the
recursion scheme.

\begin{coqcode}
Lemma hylo_fusion_l (h1 : RCoalg F A) (g1 : Alg F B) (g2 : Alg F C)
  (f2 : B ~> C) (E2 : f2 \o g1 =e g2 \o fmap f2) : f2 \o hylo g1 h1 =e hylo g2 h1.
\end{coqcode}
Using the hylo fusion law, we can prove the well-known \emph{deforestation
optimisation}. This is when two consecutive recursive computations, one that
builds a data structure, and another one that consumes it, can be fused together
into a single recursive definition. This, in turn, allows us to prove that a
recursive hylomorphism is the composition of a catamorphism and a recursive
anamorphism.
\begin{coqcode}
Lemma deforest (h1 : RCoalg F A) (g2 : Alg F C)
  (g1 : Alg F B) (h2 : RCoalg F B) (INV: h2 \o g1 =e id)
  : hylo g2 h2 \o hylo g1 h1 =e hylo g2 h1.
\end{coqcode}

\subsection{Recursive Anamorphisms}
Anamorphisms applied to recursive coalgebras specialise to hylomorphisms into an
inductive data type in the following way.  Intuitively, a recursive coalgebra
can be applied only finitely many times, therefore when this is applied to an
anamorphism the only possible traces it can produce from the seed function are
the finite ones. We denote this special kind of recursion scheme \emph{recursive
anamorphism}.  We can show that recursive anamorphisms of type \coq{X -> GFix F}
can also be given the type \coq{X -> LFix F}. Moreover, these anamorphisms are
exactly hylomorphisms on the recursive \coq{F}-coalgebra and the
algebra \coq{In} for the inductive data type \coq{LFix F}. This fact falls out
from the universality property of the hylomorphism and the fact that recursive
anamorphisms satisfy the same equation.


\subsection{Haskell Implementation of Recursion Schemes}
\begin{minted}{haskell}
newtype Fix f = In {inOp :: f (Fix f )}
\end{minted}

\begin{minted}{haskell}
cata :: Functor f => (f a -> a) -> Fix f -> a
cata alg = alg . fmap (cata alg) . In
\end{minted}
\begin{minted}{haskell}
foldr :: (a -> b -> b) -> b -> [ a ] -> b
foldr f e [ ]    = e
foldr f e (x:xs) = f x (foldr f e xs)
\end{minted}
which is very useful in list processing. As a fold, The frequently used function map is also a fold:
\begin{minted}{haskell}
map :: (a -> b) -> [a] -> [b]
map f = foldr (\x xs -> (f x):xs) []
\end{minted}

\begin{minted}{haskell}
newtype CoFix f = OutOp {out :: f (Fix f )}
\end{minted}

\begin{minted}{haskell}
ana :: Functor b => (a -> b a) -> a -> CoFix b
ana coalg = OutOp . fmap (ana coalg) . coalg
\end{minted}

 and can be
thought of as the $\operator{fmap}$ program in functional programming.
\begin{minted}{haskell}
class Functor f where
  fmap :: (a -> b) -> f a -> f b
\end{minted}


\subsection{Dump}
Given a type \coq{A} and a functor \coq{F}, an \coq{F}-algebra is a pair given
by a type \coq{A} called the \emph{carrier} of a \emph{structure map} of type
\coq{App F A ~> A}:
\begin{coqcode}
Notation Alg F A := (App F A ~> A).
\end{coqcode}
The least fixed-point for a functor \coq{F} is an instance of an \coq{F}-algebra
where the structure map is an isomorphism. This is sometimes referred to as the
\emph{initial algebra} for a functor \coq{F}. We will explain the reason behind
this name shortly. \footnote[1]{To be more precise, initial algebras are
isomorphisms by Lambek's lemma, but isomorphisms of functors do not necessarily
correspond to initial algebras.}  We define the least fixed-point of \coq{F} as
an inductive type:
\begin{coqcode}
Inductive LFix `(F : Cont Sh P) : Type := LFix_in { LFix_out : App F (LFix F) }.
\end{coqcode}
where \coq{LFix_in} is the \coq{F}-algebra while \coq{LFix_out} is its inverse.
As an example, the initial \coq{F}-algebra for the
functor \coq{F X = unit + A * X} is the type of lists with the \coq{F}-algebra
being defined by the empty list \coq{Empty : unit -> LFix F} and the cons
operation \coq{Cons : A * LFix F -> LFix F}.

We define \coq{LFix} as a setoid, where its equivalence relation can be
described as the least fixed point of \coq{AppR} and we define smart
constructors for the isomorphism of least fixed points as respectful morphisms:
\begin{coqcode}
l_in : App F (LFix F) ~> LFix F                l_out : LFix F ~> App F (LFix F)
\end{coqcode}
The least fixed-point for \coq{F} is the initial \coq{F}-algebra in the sense
that it gives rise to an inductive recursion scheme.  Specifically, for any
other \coq{F}-algebra there exists a \emph{unique} map, known as a \emph{fold} or
\emph{catamorphism}, such that it structurally deconstructs the data type
using \coq{LFix_out}, calls itself recursively and then composes the result of
the recursive call using the given an \coq{F}-algebra. In other words, for any
give \coq{F}-algebra there exists a unique \coq{F}-algebra homomorphism from the
initial one. We define it in Coq as follows:
\begin{coqcode}
  Definition cata_f `{F : Cont Sh P} (alg : Alg F A) : LFix -> A
:= fix f (x : LFix) := match x with
  | LFix_in ax => let (sx, kx) := ax in alg (MkApp sx (fun e => f (kx e))) end.
\end{coqcode}
It is easy to show that this function is a respectful morphism of
\coq{F}-algebras. In fact, it is possible to define it as a map of the
following type:
\begin{coqcode}
  cata : forall `{F : Cont Sh P} `{setoid A}, Alg F A ~> LFix ~> A
\end{coqcode}
We prove that catamorphisms satisfy the universality property we explained previously:
\begin{coqcode}
Lemma cata_univ `{eA : setoid A} (alg : Alg F A) (f : LFix ~> A)
    : f =e cata alg <-> f =e alg \o fmap f \o l_out.
\end{coqcode}
In other words, if there is any other \coq{f} with the same structural recursive
shape as the catamorphism on the algebra \coq{alg} then it must be equal to that
catamorphism.

\subsubsection{On the subtype of finite elements}
In this development we have defined recursive anamorphisms on inductive data
types. We might have as well defined them on the subtype of finite elements of
coinductive data types using a predicate which states when an element of a
coinductive data type is finite:
\begin{coqcode}
Inductive FinF : GFix F -> Prop :=
| FinF_fold (x : GFix F) : (forall e, FinF (cont (g_out x) e)) -> FinF x.
\end{coqcode}
Now the subtype \coq{{x : GFix F | FinF x}} of finite elements for \coq{GFix F}
is isomorphic its corresponding the inductive data type \coq{LFix F}. This is
easy to see. We first define a catamorphism \coq{ccata_f_} from the
subtype \coq{{x : GFix F | FinF x}} of finitary elements of \coq{GFix F} to
any \coq{F}-algebra.
\begin{coqcode}
Definition ccata_f_ `{eA : setoid A} (g : Alg F A)
  : forall x : GFix F, FinF x -> A := fix f x H :=
    let hx := g_out x in
      g (MkCont (shape hx) (fun e => f (cont hx e) (FinF_inv H e))).
\end{coqcode}
We now prove this is isomorphic to the least fixed-point of the functor
\coq{F}.
We take the catamorphism from the finite elements of \coq{GFix F} to the
inductive data type \coq{LFix F} using the \coq{F}-algebra \coq{l_in}. Its
inverse is the catamorphism on the restriction of \coq{g_in} to the finite
elements of \coq{GFix}, which we denote by \coq{lg_in}.  The following lemmas
prove the isomorphism:
\begin{coqcode}
Lemma cata_ccata `{setoid A} : cata lg_in \o ccata l_in =e id.
Lemma ccata_cata `{setoid A} : ccata l_in \o cata lg_in =e id.
\end{coqcode}
The finite subtype of \coq{GFix F} allows us to compose
catamorphisms and anamorphisms, by using the above isomorphism. In our work,
however, we use \emph{recursive} anamorphisms, defined as \coq{hylo l_in c} for
a recursive coalgebra \coq{c}, which compose easily with
catamorphisms.

\section{Mechanising Extractable Container Functors}
\label{sec:containers}
In order to abstract recursion patters we need to be able to abstract away from
the particular shape of the data.  This is achieved by introducing the concept
of \emph{functors} which have the suitable fixed-point properties, i.e.\ those
who have a initial algebras. A common approach to construct such functors is to
use \emph{containers}~\cite{AbbottAG05} (Section~\ref{sec:functors}).
However, reasoning about container equality will require us to consider both
functional extensionality and heterogeneous equality. We avoid these axioms by
introducing a custom equivalence relation on types
(Section~\ref{sec:types-morphisms}).

\subsection{Functors and Containers}
\label{sec:functors}
[CUT]
A container is defined by a type of \emph{shapes}
and a \emph{family of position types} indexed by shapes.
\begin{coqcode}
Context (Shape : Type) (Pos : Shape -> Type).
\end{coqcode}
For the functor \coq{F} we introduced in the previous paragraph we would
define \coq{Shape} as \coq{unit + A} indicating there are two constructors in
the data type and one of these contains a piece of data of type \coq{A}.
Moreover, we would define the positions as \coq{Pos (inl tt) = Empty_set}
and  \coq{Pos (inr a) = unit} indicating that the first constructor does not
have any type variables and the second constructor has one type variable.

At this point an \emph{extension} of this container is a functor defined as
follows:
\begin{coqcode}
Record App (X : Type) := MkApp { shape : Shape; contents : Pos shape -> X }.
\end{coqcode}
with the obvious action on morphisms given by post-composition
with \coq{contents}.
\begin{coqcode}
Definition fmap (f : A -> B) (x : App C A) : App C B
  := {| shape := shape x; contents := fun e => f (contents x e) |}
\end{coqcode}
In our running example, the type \coq{App X}, for some \coq{X} has two
inhabitants.  The first is a pair composed by \coq{inl tt : Shape} and a
function \coq{Pos (inl tt) -> X}. This latter is in fact a function of
type \coq{Empty_set -> X}. This pair is, therefore isomorphic to the
type \coq{unit}, the type with only one inhabitant.  The second inhabitant is
the pair composed by \coq{inr a : Shape}, for some \coq{a : A}, and a
function \coq{Pos (inr a) -> X}.  This latter type is equal to \coq{unit -> X}
which represents the elements of \coq{X} and therefore is isomorphic to \coq{X}.
This particular pair of shapes and positions is  therefore isomorphic to the
type \coq{unit + A * X}.

The correspondence between containers and polynomial functors has been
formalised in this work and can be found in the accompanying code (file
Container.v). 
% 
%Generally, any functor that
%is isomorphic to a container extension is called a \emph{container functor}.
%Here we will call \emph{container functor} the functors defined by a specific
%container extension.

\subsection{Extractable Containers}
In the previous section we defined containers using dependent types.  However,
Ocaml's type system is not equipped to handle these. To solve this problem
Coq's code extraction mechanism will insert unsafe casts.

Consider instead representing the positions of a container using a decidable
validity predicate (\coq{valid}) which assigns shapes to positions. We use
boolean functions and coercions from \coq{bool} to \coq{Prop} to represent
decidable predicates, similarly to SSReflect~\cite{GonthierL09}. The family of
positions for a given shape in a container can be recovered by defining:
\begin{coqcode}
Class Cont (Shape : Type) (APos : Type) := { valid : Shape -> APos -> bool }.
Record Pos `(C : Cont Shape APos) (shape : Shape) :=
  ValidPos { val : APos; IsValid : valid shape pos }.
\end{coqcode}
Coq's code extraction will now be able to erase the validity predicate, and
generate OCaml code that is free of unsafe casts. The OCaml code extracted for
\coq{Pos} will now be exactly the code extracted for \coq{APos}.
The decidability of the validity predicate is crucial for our purposes of 
remaining axiom-free. To illustrate this, suppose that we need to show
the equality of two container extensions. We will need to show that, for
the same positions, they will produce the same result. In Coq, the goal
would look as follows: 
\begin{coqcode}
 k : Pos C s -> X
 P1, P2 : valid s p
 ---------------------------
 k (ValidPos p P1) = k (ValidPos p P2)
\end{coqcode}
If \coq{valid} was a regular proposition in \coq{Prop}, it would not possible
to prove the equality of \coq{P1} and \coq{P2}. However, by using a decidable
predicate, if we know that \coq{P1} and \coq{P2} are of type 
\coq{valid s p = true}, then we can prove without any axioms that 
\coq{P1 = P2 = eq_refl}.


% A container extension is then defined as follows:
% \begin{coqcode}
% Context (Shape : Type) (Pos : Type) (Valid : Shape -> Pos -> Prop).
% Record App (X : Type) := { shape    : Shape;
%                           contents : {p | Valid shape p} -> X }.
% \end{coqcode}
% This approach solves the problem of the unsafe casts, since the code extracted
% for \coq{{p | Valid shape pos}} will be an OCaml singleton type defined as the
% OCaml equivalent to \coq{Pos}.

\subsubsection{Equality of Container Extensions}
Reasoning about the equality of container extensions is not entirely solved by
using decidable validity predicates to define the families of positions. In
general, we want to equate container extensions that have the same shape, and
that, for equal shape and position, they return the same element. To avoid the
use of the functional extensionality axiom, we capture this relation with the
following inductive proposition in Coq:
\begin{coqcode}
Inductive AppR `{F : Cont Sh P} {X} (x y : App F X) : Prop :=
| AppR_ext (Es : shape x = shape y)
           (Ek : forall e1 e2, val e1 = val e2 -> cont x e1 = cont y e2).
\end{coqcode}
Note that  we do not care about the validity proof of the positions, only their
value. This is to simplify (slightly) our proofs. This relation is
trivially \emph{reflexive}, \emph{transitive}, and \emph{symmetric}.

However, the use of a different equality for container extensions now forces us
to deal with the fact that some types have different definitions of equality.
In particular, we want to reason about the equality of functions of types such
as \coq{App F A -> B} (or \coq{B -> App F A}). Since 
these types now come with their own equivalence, any function that manipulates
them needs to be \emph{respectful}. I.e.\ given 
\coq{R : X -> X -> Prop} and \coq{R' : Y -> Y -> Prop},
we want functions (morphisms) that satisfy the following property:
\begin{coqcode}
forall (x y : X), R x y -> R' (f x) (f y)
\end{coqcode}

\subsection{Types and Morphisms}
\label{sec:types-morphisms}
We address the different forms of equality by defining a class of
\emph{setoids}, types with an associated equivalence relation, and considering
only functions that respect the associated equivalences, or \emph{proper}
morphisms with respect to the function \emph{respectfulness} relation. We use
the type-class mechanism, instead of setoids in Coq's standard library, to help
Coq's code extraction mechanism remove any occurence of custom equivalence
relations in the extracted OCaml code. We use \coq{=e} to denote the equivalence
relation of a setoid. By default, we associate every Coq type with the standard
propositional equality, unless a different equivalence is specified (we allow
overlapping instances, and Coq's propositional equality takes the lowest
priority).
%\begin{coqcode}
%Reserved Notation "f =e g" (at level 70, no associativity).
%Class setoid A : Type :=
%  MkEquiv
%    { eqRel : A -> A -> Prop;
%      e_refl : forall x, eqRel x x;
%      e_sym : forall x y, eqRel x y -> eqRel y x;
%      e_trans : forall x y z, eqRel x y -> eqRel y z -> eqRel x z;
%    }.
%Notation "f =e g" := (eqRel f g).
%\end{coqcode}
Given types \coq{A} and  \coq{B}, with their respective
equivalence relations \coq{eA : A -> A -> Prop} and
\coq{eB : B -> B -> Prop}, the we define the type
\coq{A ~> B} to represent \emph{proper} morphisms of the
respectfulness relation of \coq{R} to \coq{R'}.
\begin{coqcode}
Structure morph A {eA : setoid A} B {eB : setoid B} :=
  MkMorph { app :> A -> B; app_eq : forall x y, x =e y -> app x =e app y }.
Notation "A ~> B" := (@morph A _ B _).
\end{coqcode}
We rely on Coq's type class mechanism to fill in the necessary equivalence
relations. Coq's code extraction mechanism will erase any occurrence
of \coq{Prop} in the code, so objects of type \coq{A ~> B} will be extracted to
the OCaml equivalent to \coq{A -> B}. Note the implicit coercion
from \coq{A ~> B} to \coq{A -> B}.
On top of this, we define basic function composition and identity functions:
\begin{coqcode}
Notation "f \o g" = (comp f g).
Definition comp : (B ~> C) ~> (A ~> B) ~> A ~> C := ...
Definition id : A ~> A := ...
\end{coqcode}
Using custom equivalences and proper morphisms, we redefine the definitions of
container extensions and container equality. In particular, container
extensions require a proper morphism to check the validity of positions in
shapes, and container equality now uses equivalences of shapes and contained
elements: 
\begin{coqcode}
Class Cont `{setoid Shape} (Pos : Type) := { valid : Shape * Pos ~> bool }.
Inductive AppR `{F : Cont Sf Pf} `{setoid X} (x y : App F X) : Prop :=
  | AppR_ext (Es : shape x =e shape y)
             (Ek : forall e1 e2, val e1 = val e2 -> cont x e1 =e cont y e2).
\end{coqcode}
Note the use of \coq{=e} instead of Coq's standard equality.  For positions,
however, we chose to use Coq's propositional equality, since these would leads
to simpler code. We explain why in Section~\ref{sec:algebras}, and the
mechanisation of initial algebras of container extensions.
%The definitions in
%Figure~\ref{fig:poly} are redefined to account for these changes in a
%straightforward way, i.e. we prove that validity predicates are indeed proper
%morphisms. 

This definition leads to the well-known ``setoid hell'', which we mitigate by
providing tactics and notations to automatically discharge proofs of
\coq{app_eq} for morphisms, whenever the types use the standard propositional
equality, or a combination of propositional and extensional equality. However,
our compositional approach allows us to build morphisms by plugging in other
morphisms to our combinators. In our framework, our expectation is that the
user-provided functions remain small, with relatively straightforward proofs of
\coq{app_eq}.

However, by using this mechanisation, we gain simplified proofs via the use of
Coq's \emph{Generalised Rewriting}. Since every morphism \coq{f : A ~> B}
satisfies the property that if \coq{x =e y}, then \coq{f x =e f y}, we can add
every morphism as a proper element of Coq's respectfulness relation. In
practice, this means that we can use the \coq{rewrite} tactic on proofs of
type \coq{A =e B}, for arbitrary \coq{A} and \coq{B}, whenever they are used as
arguments of morphisms, as well as Coq's \coq{reflexivity}, \coq{symmmetry},
and \coq{transitivity} tactics. For example:
\begin{coqcode}
Goal forall `(f : A ~> B) `(g : B ~> C) `(h : C ~> D) (H : h \o g =e id), 
  h \o (g \o f) =e f.
Proof.  rewrite compA, H.  reflexivity. Qed.
\end{coqcode}

\subsubsection{Polynomial Types}
We define a number of equivalences for polynomial types.
%These equivalences are
%be used when building proper morphisms that manipulate their respective types.
\begin{coqcode}
Instance ext_eq (A : Type) `{eq_B : setoid B} : setoid (A -> B).
Instance pair_eq `{eq_A : setoid A} `{eq_B : setoid B} : setoid (A * B).
Instance sum_eq `{eq_A : setoid A} `{eq_B : setoid B} : setoid (A + B).
Instance prop_eq : setoid Prop.
Instance pred_sub `{eA : setoid A} {P : A -> Prop} : setoid {a : A | P a}.
\end{coqcode}
Most of the definitions that involve functions and polynomial types are
straightworward.  Identity and composition are defined as 
\coq{fun x => x} and \coq{fun f g x => f (g x)} 
respectively, and the proofs that they are proper morphisms is straightforward,
and automatically discharged by Coq. 
Products are built using function \coq{fun f g x => (f x, g x)},
with the projections being the standard Coq  \coq{fst} and
\coq{snd} functions. Similarly, sum injections are encoded using
Coq's \coq{inl} and \coq{inr} constructors, and
pattern matching on them uses the function 
\coq{fun f g x => match x with | inl y => f y | inr y => g y end}.
The proofs that these morphisms are proper are straightforward.  Finally, we
also provide functions for currying/uncurrying, and  flipping the arguments of
a proper morphism. We force most of our definitions to be inlined, to help
Coq's code extraction mechanism to inline as many of these combinators as
possible.

We prove the isomorphisms of polynomial types and the equivalent 
container extensions. As an example, we discuss (informally) the isomorphisms
of pairs with their equivalent container extensions. Suppose that we
know that \coq{App F X} is isomorphic to \coq{A}, and
\coq{App G X} is isomorphic to \coq{B}. Then we can
show that \coq{App (Prod F G) X} is isomorphic to
\coq{A * B}.  If we have an element of type 
\coq{App (Prod F G) X},
using the \coq{inl} position, we can obtain
\coq{App F X}.  Similarly, using \coq{inr}, we can
obtain \coq{App G X}. Since these are the only two valid positions
in the shape of pairs, we have finished. It is now sufficient to use the
isomorphisms of \coq{App F X} and \coq{App G X} to
obtain \coq{A * B}. Similarly if we have \coq{A * B},
we can first use the isomorphisms of 
\coq{A} and
\coq{B} to obtain
\coq{App F X * App G X}, and then construct the necessary container
extension. Given \coq{p_inl : Pos l -> Pos (l * r)} (resp. \coq{p_inr}) that
act as \coq{inl} (resp.\ \coq{inr}) on product positions, and
\coq{case_pos : (Pos l -> X) -> (Pos r -> X) -> Pos (l * r) -> X} that pattern
matches on the product positions, the functions that witness the isomorphism
are:
\begin{coqcode}
Definition iso_pair (x : App (Prod F G) X) : App F X * App G X :=
  ({| shape := shape (fst x); cont := fun e => cont x (p_inl e) |}, 
   {| shape := shape (snd x); cont := fun e => cont x (p_inr e) |}).
Definition iso_prod (x : App F X * App G X) : App (Prod F G) X :=
{| shape := (shape (fst x), shape (snd x));
   cont := case_pos (cont (fst x)) (cont (snd x)) |}.
\end{coqcode}
Proving that the composition of these functions is the identity is
straightforward using the fact that \coq{Prod} containers only have two valid
positions.

\section{Formalising Recursion Schemes}
\label{sec:recursion-schemes}
[MOVED to background]
\section{Extraction}
\label{sec:examples}
We go in this section through a series of case studies of various recursive
algorithms.  We show how they can be encoded in our framework, how can we do
program calculation techniques for optimisation, and how can they be extracted
to idiomatic OCaml code. Our examples are the Quicksort and Mergesort
algorithms (Section~\ref{sec:sorting}), dynammic programming and Knapsack
(Section~\ref{sec:knap}), and examples of the shortcut deforestation
optimisation in our framework (Section~\ref{sec:shortcut}).
%The steps are the following:
%\begin{enumerate}
%  \item Write a specification as a morphism \coq{f : A ~> B}.
%  \item Use Coq's generalised rewriting and the laws of morphisms to 
%    rewrite it to some \coq{g : A ~> B} such that \coq{f =e g}.
%  \item Project the function \coq{h : A -> B} from \coq{g}
%    (i.e. \coq{h = app g}).
%  \item Extract \coq{h} to OCaml.
%\end{enumerate}
%Note that steps 2 and 3 are \emph{proofs} that \coq{f} and \coq{h} are
%\emph{extensionally equal}. Then, Coq's extraction mechanism will erase any
%proofs from the code, and inline our definitions. To ease the application of
%these steps, we provide the following helper type:
%\begin{coqcode}
%  Record Ext (f : A ~> B) := 
%    MkExt { target :> A -> B; tgt_eq : app f =e target; }.
%\end{coqcode}
%Note that \coq{tgt_eq} will be erased when extracting \coq{Ext f} to OCaml,
%since it is in \coq{Prop}. This implies that the code extracted for \coq{Ext f}
%will be the function \coq{target} that is extensionally equal to \coq{f}.  We
%use a shortcut tactic, \coq{calculate}, that is a synonym to 
%\coq{eapply MkExt}. As a result of this tactic, we will be given the goal 
%\coq{f =e ?Goal0}. We can rewrite \coq{f}, unfold definitions, etc, and
%complete the definition with \coq{reflexivity}, and this will instantiate the
%metavariable \coq{?Goal0} to our desired function. We will use this extensively
%in our examples.
%\mvol{This is a very dry overview that doesn't need to be here. We can just jump
%  right into the examples.}
%
%\mvol{Instead of explaining what types, tactics, etc., will be used, this space should
%  be used for a little overview of the rest of the section, like: ``We will go over a series
%  of case studies of various recursive algorithms, showing how they can be encoded
%  in our framework and extracted to idiomatic OCaml code.''}
%
%\mvol{There are three sub-sections: divide-and-conquer, dynamic programming, and deforestation.
%  Each of these is written like a case study, with a particular program worked out all the way
%  to extracted OCaml code. The sub-section titles should reflect this, and there needs to be
%  a sentence at the beginning of each section re-iterating this to make the whole thing
%  flow more smoothly.}

\subsection{Sorting Algorithms}\label{sec:sorting}
Our first case study is divide-and-conquer sorting algorithms.  Encoding them
in our framework will require the use of recursive hylomorphisms and
termination proofs.  We complete the sorting algorithm examples by applying
fusion optimisation.

Both mergesort and quicksort are divide-and-conquer algorithms that can be
captured by the structure of an hylomorphisms. The structure of the recursion
is that of a binary tree.  For example, in the case of quicksort, a list is
split into a pivot, the label of the node, and two sublists. We define the data
functor of trees as follows:
\begin{coqcode}
Inductive ITreeF L N X := i_leaf (l : L) | i_node (n : N) (l r : X)
\end{coqcode}
We define the functor as a container using the following shapes and positions:
\begin{coqcode}
Inductive Tshape L A := | Leaf (ELEM : L) | Node (ELEM : A).
Inductive Tpos := | Lbranch | Rbranch. 
\end{coqcode}
These define a container, \coq{TreeF}, in a straightforward way, by making
the positions of type \coq{Tpos} only valid in \coq{Node}.
We define a series of definitions for tree container constructors and 
destructors:
% \mpav{The following algebra should be called a\_in or l\_in whatever}
\begin{coqcode}
Definition a_out {L A X : Type} : App (TreeF L A) X ~> ITreeF L A X.
Notation a_leaf x := (MkCont (Leaf _ x) (@dom_leaf _ _ _ x)).
Notation a_node x l r := (MkCont (Node _ x)
  (fun p => match val p with | Lbranch => l | Rbranch => r end)).
\end{coqcode}
The container for the Quicksort hylomorphism is \coq{TreeF unit int}, with
the following algebra and coalgebra.
\begin{coqcode}
  Definition merge : App (TreeF unit int) (list int) ~> list int.
|{ x : (App (TreeF unit int) (list int)) ~> (
           match x with
           | MkCont sx kx =>
               match sx return (Container.Pos sx -> _) -> _ with
               | Leaf _ _ => fun _ => nil
               | Node _ h => fun k => List.app (k (posL h)) (h :: k (posR h))
               end kx
           end
  )}|.
Defined.

Definition c_split : Coalg (TreeF unit int) (list int).
|{ x ~> match x with
        | nil => a_leaf tt
        | cons h t => let (l, r) := List.partition (fun x => x <=? h) t in
                      a_node h l r
        end}|.
Defined.
\end{coqcode}
We prove that the coalgebra \coq{c_split} is recursive by showing
that it respects the ``less-than'' relation on the length of the lists.
%\begin{coqcode}
%Lemma split_fin : respects_relation c_split (@length int) lt.  (* *) Qed.
%
%Definition tsplit : RCoalg (TreeF (list int) unit) (list int)
%  := mk_wf_coalg wf_lt split_fin.
%\end{coqcode}
The code that we extract for \coq{hylo merge c_split} is the following:
\begin{ocamlcode}
let rec qsort = function
| [] -> [] | h :: t ->
  let (l, r) = partition (fun x0 -> leb x0 h) t in
  let x0 = fun e -> qsort (match e with | Lbranch -> l | Rbranch -> r) in
  app (x0 Lbranch) (h :: (x0 Rbranch))
\end{ocamlcode}
Note that Coq's code extraction is unable to inline \coq{x0}, but the resulting
code is similar to a hand-written \coq{qsort}.
The mergesort algorithm can be defined analogously and can be found in the
formalisation\footnote{https://github.com/dcastrop/coq-hylomorphisms}. % [REF LINK].

% \subsubsection{Mergesort}

% Mergesort is a hylomorphism with the recursive structure defined by the
% container \coq{(TreeF (list int) unit)}.
% The computationally expensive part of the Mergesort implementation is the
% algebra, since this is where most of the comparisons happen. The recursive
% coalgebra for Mergesort is defined as the following Coq functions:
% \begin{coqcode}
% Fixpoint splitL (x : list int) (accL accR : list int) :=
%   match x with
%   | nil => (accL, accR)
%   | cons x xs => splitL xs accR (cons x accL)
%   end.

% Definition c_split : Coalg (TreeF (list int) unit) (list int) :=
% |{ x ~> match x with
%         | nil | cons _ nil => a_leaf x
%         | _ => let (l, r) := splitL x nil nil in
%                a_node tt l r
%         end
%  }|.
% Defined.
% \end{coqcode}
% Here, the notation \coq{|{ x ~> E }|} defines the morphism \coq{fun x => E},
% and uses a custom tactic to prove that it is respectful. The recursive
% coalgebra \coq{c_split} takes a list, and it returns a leaf with the input
% list, if its size is less or equal than 1. Otherwise, it applies the function
% \coq{splitL}, and divides the list in two halves.

% It is easy to prove that this coalgebra is recursive, by showing that
% it respects the relation \coq{<} on the length of the lists:
% \begin{coqcode}
% Lemma split_fin : respects_relation c_split (@length int) lt.
%   Proof. (* *) Qed.

% Definition tsplit : RCoalg (TreeF (list int) unit) (list int)
%   := mk_wf_coalg wf_lt split_fin.
% \end{coqcode}

% The algebra simply applies the \coq{mergeL} function in order to the sublists
% in every node:
% \begin{coqcode}
% Fixpoint mergeL l1 l2 {struct l1}  : list int := (* *)

% Definition merge : App (TreeF (list int) unit) (list int) ~> list int.
% |{ x ~> match a_out x with | node _ l r => mergeL l r | leaf e => e end }|.
% Defined.
% \end{coqcode}

% Putting everything together, Mergesort is defined as the following
% hylomorphism:
% \begin{coqcode}
% Definition msort := hylo merge tsplit.
% \end{coqcode}
% Note, however, that we could have composed the catamorphism and anamorphism,
% and used the deforestation result to optimise the intermediate binary tree
% away:
% \begin{coqcode}
% Definition msort : Ext (cata merge \o rana tsplit).
% calculate. rewrite (deforest l_in_out). simpl. reflexivity. Defined.
% \end{coqcode}
% In both cases, the result is the same, and it extracts to the usual divide and
% conquer definition of Mergesort in OCaml:
% \begin{ocamlcode}
% let rec msort x = match x with
% | [] -> x | _ :: l -> (match l with | [] -> x | _ :: _ ->
%      let (l0, r) = splitL x [] [] in
%      let cx = fun p -> match p with | Lbranch -> l0 | Rbranch -> r in
%      mergeL (msort (cx Lbranch)) (msort (cx Rbranch)))
% \end{ocamlcode}
\subsubsection{Fusing a divide-and-conquer computation}
As an example of how can we use program calculation techniques in our 
framework, we show how another traversal can be fused into the
divide-and-conquer algorithm using the laws of hylomorphisms.
Suppose that we map a function to the result of sorting the list. We can
use our framework to fuse both computations. In particular, consider
the following definition:
\begin{coqcode}
Definition qsort_times_two := Lmap times_two \o hylo merge c_split.
\end{coqcode}
Here, \coq{Lmap times_two} is a list map function defined as a hylomorphism,
and \coq{times_two} multiplies every element of the list by two.
We can use Coq's generalised rewriting, and \coq{hylo_fusion_l} to fuse
\coq{times_two} into the RHS hylomorphism in \coq{qsort_times_two}.
After applying hylo fusion and the necessary rewrites, the hylomorphism that we
extract is \coq{hylo (merge \o natural times_two) c_split}. In this definition,
\coq{natural} defines a natural transformation by applying \coq{times_two} to
the shapes, and \coq{times_two} multiplies every pivot in the Quicksort tree by
two. Our formalisation contains a proof that \coq{natural} is indeed a natural
transformation, which relies on the fact that it preserves the structure of the
shapes and, therefore, the validity of the positions.  The extracted OCaml code
is a single recursive traversal:
\begin{ocamlcode}
let rec qsort_times_two = function | [] -> []
| h :: t -> let (l, r) = partition (fun x0 -> leb x0 h) t in
            let x0 = fun p -> qsort_times_two (match p with
                                 | Lbranch -> l | Rbranch -> r) in
            app (x0 Lbranch) ((mul (Uint63.of_int (2)) h) :: (x0 Rbranch))
\end{ocamlcode}

\subsection{Knapsack}\label{sec:knap}
We focus now on the formalisation and extraction of \emph{dynamorphisms} for
dynamic programming, by using their encoding as a hylomorphism. We use the
knapsack example from~\cite{HinzeWG15}. Dynamorphisms build a memoisation table
that stores intermediate results, alongside the current computation. The
algebra used to define a dynamorphism can access this memoisation table to
speed up computation.  First, we define memoisation tables in terms of
containers. 
\begin{coqcode}
Definition MemoShape : Type := A * Sg.
Definition MemoPos := Pg.
Instance Memo : Cont MemoShape MemoPos := { valid := valid \o pair (snd \o fst) snd }.

Definition Table := LFix Memo.
\end{coqcode}
Memoisation tables are the least fixed point of the container defined by shapes
\coq{A * Sg} and positions \coq{Pg}, given a a container \coq{G : Cont Sg Pg}.
We define a function to insert elements into the memo tables:
\begin{coqcode}
  Definition Cons : A * App G Table ~> App Memo Table := (* *)
\end{coqcode}
And two functions to inspect the head of a memo table, and remove an
element from it:
\begin{coqcode}
Definition headT : Table ~> A := (* *)
Definition tailT : Table ~> App G Table := (* *)
\end{coqcode}
These tables map ``paths'' in the least fixed point of \coq{Memo} to elements
of type \coq{A}. For example, if \coq{G} is a list-generating functor, these
paths will be natural numbers. 
Using these definitions, a dynamorphism is defined as follows:
\begin{coqcode}
Definition dyna (a : App G Table ~> A) (c : RCoalg G B) : B ~> A
:= headT \o hylo (l_in \o Cons \o pair a id) c.
\end{coqcode}
Note how, instead of an algebra \coq{App G A ~> A}, the algebra takes a
memo table. The definition of the algebra can use this table to lookup
elements, instead of triggering a further recursive call. Elements are inserted
into the memoisation table by the use of \coq{Cons} to the result of applying
the algebra. The algebra for the dynamorphism looks up the previously computed
elements to produce the result, thus saving the corresponding recursive calls:
\begin{coqcode}
Fixpoint memo_knap table wvs :=
  match wvs with | nil => nil | h :: t =>
      match lookupT (Nat.pred (fst h)) table with
      | Some u => (u + snd h)%sint63 :: memo_knapsack table t
      | None => memo_knapsack table t
      end
  end.

Definition knapsack_alg (wvs : list (nat * int))
  (x : App NatF (Table NatF int)) : int :=
  match x with | MkCont sx kx => match sx with
  | inl tt => fun kx => 0%sint63
  | inr tt => fun kx => let tbl := kx next_elem in max_int 0 (memo_knap tbl wvs)
  end kx end.
Definition knapsackA wvs : App NatF (Table NatF int) ~> int := 
  (* [knapsack_alg wvs] as a respecful morphism *)
\end{coqcode}
The hylomorphism for knapsack is as follows, where \coq{out_nat} is the
recursive coalgebra for \coq{nat}.
\begin{coqcode}
Example knapsack wvs : Ext (dyna (knapsackA wvs) out_nat).
\end{coqcode}
Coq's code extraction mechanism is unable to inline several definitions in this
case. We have manually inlined the extracted code for simplicity. The reader
can check in our artefact that the extracted code can be trivially
inlined to produce the following:
\begin{ocamlcode}
let knapsack wvs x = let (y, _) =
    (let rec f x0 =
      if x0=0 then Uint63.of_int (0)
      else let fn := f (x0-1) in { lFix_out = { 
           shape = (max_int (Uint63.of_int (0)) (memo_knap fn wvs), sx);
           cont = fun _ -> fn } }
     in f x).lFix_out.shape in y
\end{ocamlcode}
Note how the recursive calls of \ocaml{f} build the memoisation table, and how
this memoisation table is used to compute the intermediate results in
\ocaml{memo_knap}, which is finally discarded to produce the final result.

\subsection{Shortcut Deforestation}\label{sec:shortcut}
The final case study we consider is shortcut deforestation on lists.  Shortcut
deforestation can be expressed succintly in terms of hylomorphisms and their
laws~\cite{TakanoM95}. In particular, given a function:
\begin{coqcode}
  s  : forall A. (App F A -> A) -> (App F A -> A)
\end{coqcode}
We can conclude, by parametricity, that
\begin{coqcode}
  hylo a l_out \o hylo (sigma l_in) c =e hylo (s a) c
\end{coqcode}
This is generally known as the \emph{acid rain} theorem. Unfortunately, this is
\textbf{not} provable in Coq if we want to remain axiom-free, since we would
need to add the necessary parametricity
axiom~\cite{keller_et_al:LIPIcs.CSL.2012.381}.
However, we prove a specific version of this theorem for the list generating
container (i.e.\ the container whose least fixed point is a list), and use it
to encode the example from Takano and Meijer~\cite{TakanoM95}:
\begin{coqcode}
Definition sf1 (f : A ~> B) ys : Ext (length \o Lmap f \o append ys).
\end{coqcode}
Here, we are defining function \coq{sf1} as the composition of \coq{length},
\coq{Lmap f} and \coq{append ys}. Functions \coq{length} and \coq{Lmap} are
catamorphisms. Function \coq{append ys} is also a catamorphism that
appends \coq{ys} to an input list. It is defined by applying an algebra to
every cons node of a list, and applying a catamorphism with the input algebra
to \coq{ys} in the nil case:
\begin{coqcode}
Definition tau (l : list A) (a : Alg (ListF A) B) : App (ListF A) B -> B :=
  fun x => match x with | MkCont sx kx => match sx with
  | s_nil => fun _ => (hylo a ilist_coalg) l
  | s_cons h => fun kx => a (MkCont (s_cons h) kx)
  end kx end.
Definition append (l : list A) := hylo (tau l l_in) ilist_coalg.
\end{coqcode}
Here, \coq{ilist_coalg} is a recursive coalgebra from Coq lists to the
\coq{ListF} container. We apply the hylo fusion law repeatedly, unfold
definitions, and simplify in our specification for \coq{sf1}:
\begin{coqcode}
Definition sf1 (f : A ~> B) ys : Ext (length \o Lmap f \o append ys).
  rewrite hylo_map_fusion, <- acid_rain. simpl; reflexivity.
Defined.
\end{coqcode}
From this, we extract the following OCaml code:
\begin{ocamlcode}
let rec sf1 f ys = function | [] -> let rec f0 = function
                                      | [] -> (Uint63.of_int (0))
                                      | _ :: t -> add (Uint63.of_int (1)) (f0 t)
                                    in f0 ys
                            | _ :: t -> add (Uint63.of_int (1)) (sf1 f ys t)
\end{ocamlcode}

We then prove that the length function fuses with
the naive quadratic \emph{reverse} function:
\begin{coqcode}
Definition sf2 : Ext (length \o reverse).
  calculate.  unfold length, reverse. rewrite hylo_fusion_l.
  2:{ (* Rewrite into the fused version *) }
  simpl; reflexivity.
Defined.
\end{coqcode}
This code extracts to the optimised length function on the input list:
\begin{ocamlcode}
let rec ex2 = function | [] -> (Uint63.of_int (0))
                       | _ :: t -> add (Uint63.of_int (1)) (ex2 t)
\end{ocamlcode}

\section{Related Work}
\label{sec:related-work}
%
%\begin{itemize}
%  \item McBride devised a generalisation of Bove and Capretta's general
%recursive function monad~\cite{McBride15, BoveC01}
%  \item Guarded recursion for productive definitions and general recursion
%~\cite{AtkeyM13, PaviottiMB15}
%  \item PACO library~\cite{HurNDV13}
%  \item Sized Types \cite{HughesPS96, abs-1202-3496}
%  \item Copatterns \cite{AbelPTS13, AbelP16}
%  \item Not that related: extraction for mutable arrays~\cite{SAKAGUCHI2020102372}
%        \item Extraction of Distributed Mobile code in Coq~\cite{MiculanP12}.
%\end{itemize}
Encoding recursion schemes in Coq is not new. We compare our work with other
encodings of program calculation techniques in Coq and recursion schemes in Coq
(Sections~\ref{sec:calccoq} and~\ref{sec:reccoq}). Additionally, we compare our
encoding of recursion schemes to other forms of termination checking
(Section~\ref{sec:termcheck}, as a way to guarantee termination of nonstructural
recursion.

\subsection{Program Calculation}\label{sec:calccoq}

Within the domain of program optimization, program calculation serves as a
well-established programming technique aimed at deriving efficient programs from
their naive counterparts through systematic program
transformation~\cite{gibbonsSquiggol}. Programmers may specify algorithms
abstractly at a high level, and then derive an efficient implementation using
the process of program calculation~\cite{BirddeMoor96:Algebra}. This area has
been extensively explored over the years.

Tesson et al.\ demonstrated the efficacy of leveraging Coq to establish an
approach for implementing a robust system dedicated to verifying the correctness
of program transformations for functions that manipulate
lists~\cite{10.1007/978-3-642-17796-5_10}. Murata and Emoto went further and
formalised recursion schemes in Coq~\cite{MurataE19}. Their development does not
include hylomorphisms and dynamorphisms, and relies on the functional
extensionality axiom, as well as further extensionality axioms for each
coinductive datatype that they use. They do not discuss the extracted OCaml code
from their formalisation. Larchey-Wendling and Monin encode recursion schemes in
Coq, by formalising computational graphs of algorithms~\cite{larchey2022braga}.
Their work does not focus on encoding generic recursion schemes, and proving
their algebraic laws. Castro-Perez et al.~\cite{farmsCastro} encode the laws of
hylomorphisms as part of the type system of a functional language to calculate
parallel programs from specifications. Their work focuses on parallelism, and
they do not formalise their approach in a proof assistant, and the laws of
hylomorphisms are axioms in their system.

%\mvol{Need more general citations for program calculation.}
\subsection{Divide and Conquer Recursion}\label{sec:reccoq}

Abreu et al.~\cite{AbreuDHJMS23} encode divide-and-conquer computations in Coq,
using a recursion scheme in which termination is entirely enforced by its
typing.  This is a significant advance, since it avoids \emph{completely} the
need for termination proofs. Their work differs from ours in that they require
the functional extensionality axiom, and the use of impredicative \coq{Set}.
The authors justify well the use of impredicative \coq{Set} and its
compatibility with the functional extensionality axiom. In contrast, our
development remains entirely \emph{axiom-free}. Another key difference with our
approach is that they do not discuss what the resulting extracted code
\emph{looks like} (that is, whether the extracted OCaml code resembles the
natural formulation of the recursive function). Through experiments, we found
that their formalisation leads to \ocaml{Obj.magic}, and code with a complex
structure that may be hard to understand or interface with other OCaml code.
Due to the great benefit of entirely avoiding termination proofs, it would be
interesting to extend their approach to improve code extraction.

\subsection{Termination Checking}\label{sec:termcheck}

Termination and productivity are non-trivial properties of programs, and various
methods have been proposed for checking that these properties hold. A common
approach is guardedness checking~\cite{Eduardo94}, which is a
\emph{syntactic} check that definitions avoid the introduction of
non-normalizable terms. This sort of check generally looks for a
\emph{structural decrease} of arguments in the recursive calls of a function.
Coq uses such a check, and it works for many classic functional programming
patterns (like \haskell{map} and \haskell{foldr}). However, some desirable
definitions will not be accepted by such checks.

\mvol{Do we need to discuss this or can we cut it?}

In particular, the problem of \emph{nonstructural recursion} (including
divide-and-conquer algorithms) is well-studied~\cite{BoveKS16}.
% A distinction between standard and
% nonstandard recursion lies in the fact that standard recursion adheres strictly
% to recursing on pattern variables, avoiding reliance on results from other
% function calls. Nonstandard recursion may deviate from this convention, allowing
% for more flexibility.
Certain functions that are not structurally recursive can be reformulated using
a nonstandard approach to achieve structural recursion~\cite{AbreuDHJMS23}.
Take, for instance, division by iterated subtraction, which is inherently
non-structurally recursive since it involves recursion based on the result of a
subtraction. There is a nonstandard implementation of divivion found on Coq's
standard library, which involves a four-argument function that effectively
combines subtraction and division. Similarly, the mergesort in Coq's standard
library uses an ``explicit stack of pending merges'' in order to avoid issues
with nonstructural definitions. There is a major downside, however; as noted by
Abreu et al., the result is ``barely recognizable as a form of
mergesort''~\cite{AbreuDHJMS23}.

\section{Conclusions and Future Work}

Hylomorphisms are a general recursion scheme that can encode any other
recursion scheme, and that satisfy a number of algebraic laws that can be used
to reason about program equivalences. To our knowledge, this is their first formalisation
in Coq. This is partly due to the
difficulty of dealing with termination, and reasoning about functional
extensionality. In this work, we tackle these problems in a \emph{fully
axiom-free} way that targets the extraction of idiomatic OCaml code.  This
formalisation allows the use of program calculation techniques in Coq to derive
formally optimised implementations from naive specifications. Furthermore, the
rewritings that are applied to specifications are formal, machine-checked
proofs that the resulting program is extensionally equal to the input
specification. 

Remaining axiom-free forces us to deal with the well-known
\emph{setoid hell}. As part of the future improvements, we will study how to
mitigate this problem. At the moment, we use a short ad-hoc tactic that is able
to automatically discharge many of these proofs in simple settings.  We will
study the more thorough and systematic use of proof automation for respectful
morphisms.  Generalised rewriting in proofs involving setoids tends to be quite
slow, due to the large size of the terms that need to be rewritten. Sometimes,
this size is hidden in implicit arguments and coercions. We will study
alternative formulations to try to improve the performance of the rewriting
tactics (e.g.\ canonical structures).  Currently, Coq is unable to inline a
number of trivially inlineable definitions.  We will study alternative
definitions, or extensions to Coq's code extraction mechanisms to force the
full inlining of all container code that is used in hylomorphisms.  Finally,
proving termination still remains a hurdle. In our framework this reduces to
proving that the anamorphism
terminates in all inputs, and we provide a convenient connection to
well-founded recursion. Furthermore, recursive coalgebras compose with natural
transformations, which allows the reuse
of a number of core recursive coalgebras. A possible interesting future line of work
is the use of the approach by Abreu et al.~\cite{AbreuDHJMS23} in combination with ours to
improve code extraction from divide-and-conquer computations whose termination
does not require an external proof. 



\bibliography{references.bib}

\end{document}

\endinput
\appendix
\section{Polynomial Functors as Container Extensions}
\label{sec:pol-containers}
Polynomial functors can be defined as container extensions~\ref{fig:poly}. We
omit here the proofs that these container extensions are isomorphic to
polynomials, but this proof is straightforward. To illustrate how the identity,
constant, sum and product container extensions work, consider the
tree-generating functor (i.e.\ the functor whose fixpoint is a binary tree):
$F\; X = \mathbb{N} + X \times X$.

This functor is built as the sum of two functors: $X \mapsto \mathbb{N}$ and $X \mapsto
X \times X$. Consider first $X \mapsto \mathbb{N}$. This is a constant functor
that maps $X$ to the type $\mathbb{N}$. More generally, a functor that, given a
type $A$, maps everything to it, $X \mapsto A$, only needs one shape ($A$, L9
of Fig~\ref{fig:poly}), and zero positions (In Coq, \coq{False},
L10 of Fig~\ref{fig:poly}). The reason why there are zero valid positions in
a constant container extension is because, given something of type
\coq{App (Const (Ks A) Kp) X}, it should be impossible to get
something of type \coq{X}. But from the container shape, we will
always be able to get the element of type $A$\footnote{%
  Our decision to use \coq{False} is arbitrary. In general, we
  could have chosen any time, with a validity predicate that always returns
  \coq{false}. It would make no difference for code extraction.
}. This functor is, therefore \coq{Const nat}.

Consider now $X \mapsto X \times X$. This is the product of two
identity functors $X \mapsto X$. The identity functor only has one shape, and
we can use the unit type to represent such shapes. From this shape we should be
able to get an element of type $X$, and we can capture this by using the unit
type for positions. To build an element of the container extension type, we
will need to provide a function of type \coq{unit -> X}, which is
isomorphic to \coq{X}.

The shape of the product of two container extensions is the product of their
shapes. The product of such container extensions should allow us to get either
the left, or the right element in the product. Therefore, the positions of this
container extension is the sum of the positions of the two container
extensions. What is a valid position in a given shape? If the position is
\coq{inl p} (or \coq{inr p}), then it is only valid if
\coq{p} is valid in the first (resp. second) component of the
shape. The product of our two container extensions is
\coq{Prod Id Id}.

Finally, the shape the sum of two container extensions is the sum of their
shapes. The positions are, like for products, the sum of their shapes. But to
check the validity of shapes in positions, their constructor must match, e.g.
shape \coq{inl s} and shape \coq{inl p}, with
\coq{valid s p}.

Our final container extension is the following:
\coq{Sum (Const nat) (Prod Id Id)}.
The shape of this functor is:
\coq{nat + unit * unit}. The positions of this functor
are \mintinline[breaklines]{Coq}{False + (unit + unit)}, which is isomorphic
to \coq{unit + unit}, which will only be valid in the RHS.

The Coq value \coq{inl n} of type
\coq{nat + bool * bool} would look as follows as a container
extension
\coq{App (Sum (Const nat) (Prod Id Id)) bool}:
\begin{coqcode}
{| shape := inl n; cont := fun e => uninhabited e|}
\end{coqcode}
We omit the definition of \coq{uninhabited}, which exploits the
fact that \coq{e} for \coq{inl n} implies
\coq{False} to build an element of type \coq{bool}%
\footnote{Note that, since \coq{e} is uninhabited we could return
any arbitrary value instead of \coq{uninhabited e}.}.

Similarly, the Coq value \coq{inr (true, false)} as a container
extension is as follows:
\begin{coqcode}
  {| shape := inr (tt,tt);
     cont := fun e : {p | valid (inr (tt, tt)) p} =>
        match proj1_sig e with
        | inl f => match f with end
        | inr (inl tt) => fun _ => true
        | inr (inr tt) => fun _ => false
        end
  |}
\end{coqcode}
Here, the position \coq{inl f} is impossible, as
\coq{f} would need to be a proof of \coq{False}.
Of the two remaining positions, the left one will return
\coq{true}, and the right position \coq{false}.
\begin{figure}
\begin{minipage}{.52\textwidth}
  \begin{minted}[linenos, fontsize=\small]{Coq}
Context `(C1 : Cont S1 P1)
        `(C2 : Cont S2 P2).

Definition Is := unit.
Definition Ip := unit.
Instance Id : Cont Is Ip := {
  valid := fun _ _ => true }.

Definition Ks (A : Type) := A.
Definition Kp := False.
Instance Const A : Cont (Ks A) Kp := {
  valid := fun _ p =>
    match p with end }.

Definition Ps : Type := S1 * S2.
Definition Pp : Type := P1 + P2.
Instance Prod : Cont Ps Pp := {
  valid := fun s p =>
    match p with
    | inl p' => valid (fst s) p'
    | inr p' => valid (snd s) p'
    end }.
\end{minted}
\end{minipage}
\begin{minipage}{.47\textwidth}
  \begin{minted}[linenos, firstnumber=23, fontsize=\small]{Coq}
Definition Ss : Type := S1 + S2.
Definition Sp : Type := P1 + P2.
Instance Sum : Cont Ss Sp := {
  valid := fun s p =>
    match s, p with
    | inl s', inl p' => valid s' p'
    | inr s', inr p' => valid s' p'
    | _, _ => false
    end }.

Definition Cs : Type := App F S2.
Definition Cp : Type := P1 * P2.
Instance Comp : Cont Cs Cp :=
{ valid :=
    fun (s : App F S2) (p : P1 * P2) =>
        match valid (shape s) (fst p)
        with
        | true  => fun H =>
            valid (cont s {fst p | H})
                  (snd p)
        | false => fun _ => false
        end eq_refl }.
  \end{minted}
\end{minipage}
  \caption{Polynomials as Container Extensions (simplified). In order: identity
  (L4-7), constant (L9-13), product (L15-22), sum (L23-31), composition
  (L33-44).}
  \label{fig:poly}
\end{figure}


\section{On Equality}
This definition highlights why we cannot define equality of the positions and
the contained elements generically: the
contained types may not have (yet) an associated equivalence. In other words, we
would need to provide an equivalence for \coq{LFix}, but the only way to do this
is to define such equivalence simultaneously to the definition for  \coq{LFix}.
Such definition would be rejected by Coq. There are other approaches that can
circumvent this problem, by separating the definition of least fixed points from
the proofs that the functions that get the contained elements are proper
morphisms. But this leads to longer, unnecessarily complicated proofs.
Furthermore, this extra layer interferes with code extraction, in that it
requires destructing/constructing subsequent \coq{LFix} and \coq{App}, and Coq
may not always able to inline them.

\mpav{Dumped here}
We define the equality of initial algebras of container extensions recursively,
by traversing the structure and equating the shapes and positions. This
definition is equivalent to taking the fixpoint of \coq{AppR} where the shapes
must be equivalent and, for equal positions, the contents must be related by
\coq{LFixR}.
\begin{coqcode}
Fixpoint LFixR (x y : LFix) : Prop :=
  let f_x := LFix_out x in
  let f_y := LFix_out y in
  shape f_x =e shape f_y /\
    (forall e1 e2, val e1 = val e2 -> LFixR (cont f_x e1) (cont f_y e2)).
\end{coqcode}

\begin{coqcode}
Definition GFixR : GFix -> GFix -> Prop :=...
Instance GFix_setoid : setoid GFix := ...GFixR...
\end{coqcode}

\section{Course-of-Value Recursion with Finite Memory Table}
It can be proven that if $c$ is a recursive coalgebra, then the hylomorphism for
any algebra $a$ generates a finite output.  In other words, as far as the
hylomorphism is concerned $G_{\infty}$ can be regarded as its finite version
\[
  G_{*} A = \mu X. A \times G X
\]
We now rewrite course-of-value recursion using the finite memory table
For an algebra $a : D(D_{*} A) \to A$,
\begin{align*}
  & g : \mu F \to A
  & g = a \comp D(G_{*}(g) \comp \anacofree{\cata{G^{\lambda}(\InIso)}}) \comp \InOp
\end{align*}


\section{Adjoint Folds}
In order to transform $\operator{even-odd}$ into two functions $\operator{even}$
and $\operator{odd}$ we are going to use something called an ``adjunction''.  In
particular, we have two functors. The diagonal functor
$\Delta : \CatC \to \CatC \times \CatC$ defined as $\Delta X = (X,X)$ and the
product functor $\times : \CatC \times \CatC$. These two functors form an
adjunction:
\[\begin{tikzcd}
	{\CatC \times \CatC} & \CatC
	\arrow[""{name=0, anchor=center, inner sep=0}, "\Delta"', shift right=2, from=1-2, to=1-1]
	\arrow[""{name=1, anchor=center, inner sep=0}, "\times"', shift right=2, from=1-1, to=1-2]
	\arrow["\dashv"{anchor=center, rotate=-90}, draw=none, from=0, to=1]
    \arrow["D"', loop, distance=2em, in=35, out=325, from=1-2, to=1-2]
    \arrow["\Delta\circ D\circ \times "', loop, distance=2em, in=215, out=145, from=1-1, to=1-1]
\end{tikzcd}
\]
More formally, this means there is a one-to-one correspondence of maps, i.e.
every map $(A,A) \to (B_{1}, B_{2})$ corresponds univocally to a map of type
$A \to B_{1} \times B_{2}$. In the isomorphism below we use $\ceiling{\cdot}$
and $\floor{\cdot}$ to denote the maps witnessing the isomorphism called
respectively the right and left transpose of the adjunction:
\[
  \floor{\cdot} : \CatC \times \CatC ((A, A) , (B_{1}, B_{2}) \iso \CatC (A , B_{1} \times B_{2}): \ceiling{\cdot}
\]
the right transponse $\ceiling{\cdot}$ of the adjunction can be
defined using the projections:
\[
  \ceiling{g} = (\pi_{1} \cdot g,\pi_{2}\cdot g)
\]
and the floor can be defined as using the pair into the product:
\[
  \floor{f}(a) = \pair{f(a)}{f(a)}
\]

We can instantiate further the iso by setting $A = \Nat$, $B_{1} = \Bool$ and
$B_{2} = \Bool$.
\[
  \floor{\cdot}: \CatC \times \CatC ((\Nat, \Nat) , (\Bool, \Bool) \iso \CatC (\Nat , \Bool \times \Bool) : \ceiling{\cdot}
\]
% At this point we are pretty much done as we can instantiate the diagrams
% (\ref{eq:canonical-adjoint-fold}) where $D X = 1 + X$
% \[
%   \begin{tikzcd}
% 	{(1 + \Nat, 1 + \Nat)} && (1 + \Bool \times \Bool, 1 + \Bool \times \Bool) & { 1 + \Nat} & 1 + (\Bool \times \Bool) \\
% 	{(\Nat, \Nat)} && (\Bool, \Bool) & {\Nat} & \Bool \times \Bool
% 	\arrow["{\cata{a}}"', from=2-4, to=2-5]
% 	\arrow[""{name=0, anchor=center, inner sep=0}, "{\InIso}"', from=1-4, to=2-4]
% 	\arrow["{1 + \cata{a}}", from=1-4, to=1-5]
% 	\arrow["a", from=1-5, to=2-5]
% 	\arrow["{\ceiling{\cata{a}}}"', from=2-1, to=2-3]
% 	\arrow["{(1 +  \InIso,1 +  \InIso)}"', from=1-1, to=2-1]
% 	\arrow["{(1 + \cata{a}, 1 + \cata{a})}", from=1-1, to=1-3]
% 	\arrow[""{name=1, anchor=center, inner sep=0}, "\ceiling{a}", from=1-3, to=2-3]
% 	\arrow[shorten <=35pt, shorten >=35pt, Rightarrow, 2tail reversed, from=1, to=0]
%   \end{tikzcd}
% \]
% Now we define $a$ to be the following $D$ algebra:
% \begin{align*}
%   & a : 1 + \Bool \times \Bool \to \Bool\\
%   & a (\operator{nil}) = (\top, \bot)\\
%   & a (b_{1}, b_{2}) = (\neg b_{1}, \neg b_{2})
% \end{align*}

We already seen that the catamorphism over the algebra $a$ equals
$\operator{even-odd}$. By using the right transpose we can derive the pair of
original functions $(\operator{even}, \operator{odd})$:
\[
  \ceiling{\operator{even-odd}} = (\pi_{1}\cdot \operator{even-odd}, \pi_{2}\cdot \operator{even-odd})
\]
To show this pair of functions are the same as the original ones we appeal to
uniqueness of catamorphisms. Recall that catamorphisms for a generic $F$ algebra
$a$ are the unique maps such that
\[
  \cata{a} = a \comp F(\cata{a})\comp \InIso^{\circ}
\]
This is represented on the right hand side of the following diagrams:
\[
  \begin{tikzcd}
	{(1 + \Nat, 1 + \Nat)} && (1 + \Bool^{2}, 1 + \Bool^{2}) & {1 + \Nat} & 1 + \Bool^{2} \\
	{(\Nat, \Nat)} && (\Bool, \Bool) & {\Nat} & \Bool^{2}
	\arrow["{\operator{eo}}"', dotted,  from=2-4, to=2-5]
	\arrow[""{name=0, anchor=center, inner sep=0}, "{\InIso}"', from=1-4, to=2-4]
	\arrow["{1 + \operator{eo}}", dotted, from=1-4, to=1-5]
	\arrow["a", from=1-5, to=2-5]
	\arrow["{\ceiling{\operator{eo}}}"', from=2-1, to=2-3]
	\arrow["{(1 +  \InIso,1 +  \InIso)}"', from=1-1, to=2-1]
	\arrow["{(1 + \operator{eo}, 1 + \operator{eo})}", from=1-1, to=1-3]
	\arrow[""{name=1, anchor=center, inner sep=0}, "\ceiling{a}", from=1-3, to=2-3]
	\arrow[shorten <=20pt, shorten >=20pt, Rightarrow, 2tail reversed, from=1, to=0]
  \end{tikzcd}
\]
The double implication in the middle of these two diagrams states that the
catamorphism on the right is in one-to-one correspondences with the right
transpose of $\operator{eo}$ satisfying the right-hand side diagram. Notice the
right-hand side is exactly the definition of the pair of functions
$\operator{even}$ and $\operator{odd}$ and the diagram states these correspond
to $\operator{even-odd}$ given by a catamorphism on the left. Since this latter
is the unique catamorphism the one on the right is also unique such that it
makes the right-hand side diagram commute.

\subsection{The General Case}

\[\begin{tikzcd}
	{\CatC} & \CatD
	\arrow[""{name=0, anchor=center, inner sep=0}, "L"', shift right=2, from=1-2, to=1-1]
	\arrow[""{name=1, anchor=center, inner sep=0}, "R"', shift right=2, from=1-1, to=1-2]
	\arrow["\dashv"{anchor=center, rotate=-90}, draw=none, from=0, to=1]
    \arrow["D"', loop, distance=2em, in=35, out=325, from=1-2, to=1-2]
    \arrow["LDR"', loop, distance=2em, in=215, out=145, from=1-1, to=1-1]
\end{tikzcd}
\]

The following is a natural isomorphism arising from the adjunction $L \dashv R$.
\begin{equation}
  \label{eq:adjoint-iso}
  \floor{\cdot} : \CatC(LA, B) \iso \CatD (A, RB) : \ceiling{\cdot}
\end{equation}
Some properties of adjunctions are worth recalling.  The unit and counit of the
adjunction can be defined from the above isomorphism as follows:
\[
  \eta_{A} = \floor{id_{LA}} \qquad \epsilon_{B}  = \ceiling{id_{RB}}
\]
Conversely, the isomorphism can be defined in terms of the two functors $L$ and
$R$ and the units of the adjunction:
\begin{align*}
  & \floor{f : LA \to B} = A \xrightarrow{\eta_{A}} RLA \xrightarrow{R(f)} RB\\
  & \ceiling{g : A \to RB} = LA \xrightarrow{L(g)} LRB \xrightarrow{\epsilon_{B}} B
\end{align*}
These definitions are going to be useful later to understand the definitions of
the recursion schemes we are going to prove correct.

As a result, the following two diagrams (recursion schemes) are equivalent. The
on the right hand side is a \emph{catamorphism} taking a $D$ algebra on $RB$ and
construting an inductive function over the data type $\mu D$. The one on the
left hand side is the derived recursion scheme where the data type has been
wrapped up in $L$. The transformation is done by just applying the isomorphism
(\ref{eq:adjoint-iso}) given by the adjunction.

\begin{equation}
  \label{eq:canonical-adjoint-fold}
  \begin{tikzcd}
	{LD\mu D} & LDRB && {D\mu D} & DRB \\
	{L\mu D} & B & {} & {\mu D} & RB
	\arrow["{\cata{a}}"', from=2-4, to=2-5]
	\arrow[""{name=0, anchor=center, inner sep=0}, "{\InIso}"', from=1-4, to=2-4]
	\arrow["{D(\cata{a})}", from=1-4, to=1-5]
	\arrow["{\floor{a}}", from=1-5, to=2-5]
	\arrow["{\ceiling{\cata{a}}}"', from=2-1, to=2-2]
	\arrow["{L(\InIso)}"', from=1-1, to=2-1]
	\arrow["{LD(\cata{a})}", from=1-1, to=1-2]
	\arrow[""{name=1, anchor=center, inner sep=0}, "a", from=1-2, to=2-2]
	\arrow[shorten <=28pt, shorten >=28pt, Rightarrow, 2tail reversed, from=1, to=0]
  \end{tikzcd}
\end{equation}

In the following section we instantiate the adjoint fold with some instances
taken from the literature.

\end{document}

%%% Local Variables:
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
