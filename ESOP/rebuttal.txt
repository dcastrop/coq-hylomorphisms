We would like to thank the reviewers for their constructive feedback, which has
helped us clarify our contributions and refine the positioning of our work.

A common theme among the reviewers is the need for a clearer presentation of the
motivation behind our work, which we address here in summary.

While the individual components of this work are well-known, as correctly noted
by Reviewer A, their integration into a cohesive framework has not been
previously studied. Although this might initially seem like a limitation, we
argue that it represents an essential necessary step forward in the area of
recursion schemes in the context of type theory.

In fact, recursion schemes have been explored extensively in the context of
functional programming languages like Haskell, where their theoretical soundness
has been shown by Hinze, Wu and Gibbons. However, in practice, these schemes
have never been used in practice to guarantee termination, simply because
Haskell allows invalid algebras and functors to be used with them.

To address this gap, our work encodes recursion schemes within a proof assistant
-- Coq -- ensuring termination by design and enabling extraction to executable
code in a programming language. Containers and setoids are used as standard
tools to achieve this goal.

We believe this approach benefits both the programming and type theory
communities. For programmers, it offers a practical library that ensures
termination and correctness. For type theorists, it contributes to addressing
the long-standing challenge of defining recursive constructions in systems like
Coq or Agda.

We believe our work is a first step in try to understand how recursion schemes
can be integrated in type theories to tackle termination challenges. We intend
to have a more theoretical follow up addressing corecursive algorithms.

Reviewer A
------------------------------------
Comment:
> Setoid-based reasoning is well understood (if painful). Containers have been
> studied and also formalized before, though I think mostly in Agda...The material
> on hylomorphisms and examples itself is not new...So it seems what is new is how
> to put the pieces together to avoid the various pitfalls in formalizing
> hylomorphisms in Coq to maintain the ability to generate OCaml code.

We agree with the reviewer that setoid reasoning, hylomorphisms and containers
are established topics. As correctly pointed out by the reviewer however they
have never been pieced together. In particular, the whole area of recursion
schemes has only been considered within the broader realm of functional
programming. In this setting, it is still possible to introduce non-termination,
e.g. by feeding the recursion scheme with invalid non-terminating algebras.
Hence recursion scheme have mostly been used to structure programs for reasoning
rather than ensuring formally that they define terminating functions.

This work can be viewed as a first step towards considering the use of recursion
 schemes to help proof assistants to accept more recursive definitions.

The issue of extracting runnable code is perhaps tangential but still helpful
from a programming point of view as 1) OCaml does not have full access to
recursion schemes since there is no way of declaring a functor as easily as for
example in Haskell and 2) it provides

Comment: "The code that is generated still looks like it would need additional
work to incorporate into a program dealing with, say, ordinary lists or trees
defined using OCaml datatypes rather than as container equivalents."

[DAVID TO DO]


Reviewer B
------------------------------------
Comment:
> I am struggling to position this work in a particular area...Is this
> an elaborate new Coq library thatâ€™s going to be useful to lots of people? Does
> it provide any major take-away lessons for Coq programming?

Our primary goal is to provide a framework that advances the formalization and
practical usability of recursive schemes like hylomorphisms in Coq, particularly
with a focus on sound OCaml code extraction. While this work includes the
implementation of a Coq library, its broader significance lies in showcasing how
termination-sensitive constructs like hylomorphisms can be handled rigorously
within Coq's framework, offering insights into programming techniques that
balance formal reasoning with practical usability.

Comment:
> Above I have guessed what the take-aways are, but this is not
> summarized in the introduction.

Thank you for highlighting this. We will revise the introduction accordingly.


Reviewer C
------------------------------------
Comment:
> I could not understand what is the real motivation of this study. Is
> it a case study of various Coq features, including the OCaml-code extraction
> function?


Comment:
> In a real situation, does an OCaml programmer use this to write a
> program? For the latter, why does using Coq help with which problem of
> hylomorphisms?


Comment:
> I felt that there is little self-contained and detailed explanation on
> the termination issue.

